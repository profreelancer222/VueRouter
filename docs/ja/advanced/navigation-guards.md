# ナビゲーションガード

この名前が示すように、 `vue-router` によって提供されるナビゲーションガードは、リダイレクトもしくはキャンセルによって遷移をガードするために主に使用されます。ルートナビゲーション処理 (グローバル、ルート単位、コンポーネント内) をフックする多くの方法があります。

### グローバルガード

`router.beforeEach` を使ってグローバル before ガードを登録できます。

``` js
const router = new VueRouter({ ... })

router.beforeEach((route, redirect, next) => {
  // ...
})
```

いつナビゲーションがトリガーされようとも、グローバル before ガードは作られた順番で呼び出されます。ガードは非同期に解決されるかもしれません。そしてそのナビゲーションは全てのフックが解決されるまで **未解決状態** として扱われます。

全てのガード関数は 3 つの引数を受け取ります。

- `route: Route`: 次にナビゲーションされる対象の [ルートオブジェクト](../api/route-object.md)。

- `redirect: Function`: この関数を呼び出すことで現在のナビゲーションを中止してリダイレクト対象先の新しいナビゲーションが始まります。

- `next: Function`: このガードを解決し、パイプラインの次のガードに進みます。もしフックが残っていない場合は、このナビゲーションは **確立** されます。

**もし `redirect` も `next` も呼ばれない場合、そのナビゲーションはキャンセルされます。**

グローバル after フックを登録することもできます。しかしながら、ガードとは異なり、これらのフックはより単純で、ナビゲーションに影響を与えることはできません。

``` js
router.afterEach(route => {
  // ...
})
```

### ルート単位ガード

直接ルート設定オブジェクトの `beforeEnter` ガードを定義することができます。

``` js
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (route, redirect, next) => {
        // ...
      }
    }
  ]
})
```

これらのガードはグローバル before ガードと全く同じシグネチャを持ちます。

### コンポーネント内ガード

最後に、 `beforeRouteEnter` と `beforeRouteLeave` を使ってルートコンポーネント内側でルートナビゲーションガードを直接定義することができます。

``` js
const Foo = {
  template: `...`,
  beforeRouteEnter (route, redirect, next) {
    // このコンポーネントをレンダリングするルートが確立する前に呼ばれます。
    // `this` でのこのコンポーネントへのアクセスはできません。
    // なぜならばこのガードが呼び出される時にまだ作られていないからです!
  },
  beforeRouteLeave (route, redirect, next) {
    // このコンポーネントをレンダリングするルートが間もなく
    // ナビゲーションから離れていく時に呼ばれます。
    // `this` でのコンポーネントインスタンスへのアクセスができます。
  }
}
```

この `beforeRouteEnter` ガードは `this` へのアクセスは**できない**です。なぜならば、ナビゲーションが確立する前にガードが呼び出されるからです。したがって、新しく入ってくるコンポーネントはまだ作られていないです。

しかしながら、 `next` にコールバックを渡すことでインスタンスにアクセスすることができます。このコールバックはナビゲーションが確立した時に呼ばれ、コンポーネントインスタンスはそのコールバックの引数として渡されます。

``` js
beforeRouteEnter (route, redirect, next) {
  next(vm => {
    // `vm` を通じてコンポーネントインスタンスにアクセス
  })
}
```

`beforeRouteLeave` 内で直接 `this` にアクセスすることができます。この去る際のガードは通常はユーザーが不意に編集を保存していない状態でこのルートを去ることを防ぐために使われます。このナビゲーションは単純に `next` もしくは `redirect` を呼ばなければキャンセルされます。
